# 面试

## 计算机网络

## 设计模式

### 六大原则

- 单一职责原则。
- 开闭原则。
- 里氏替换原则。
- 依赖倒置原则。
- 接口隔离原则。
- 迪米特法则（最少知道原则）。

### 经典 21 种设计

- 单利模式
- 工厂模式
- 代理模式
- 建造者模式
- 模板方法模式
- 外观模式（门面模式）
- 原型模式
- 策略模式
- 观察者模式
- 。。。
- 装饰器模式

## Java SE

## 集合

### List

- ArrayList
- LinkedList

### Map

- 链表转红黑树阈值：8
- 扩容方法 resize 调用条件：
  - map 初始化。
  - map 中存储的 key-value 数量大于 threshold 。

#### ConsurrentHashMap

- HashTable 使用 synchronized 对全表加锁，锁的粒度大效率低。
- JDK 1.7 使用 segement 数组 + HashEntry 链表数组结构，对 segement 加锁实现同步，相对于 HashTable 降低了锁的粒度。
- JDK 1.8 之后，结构与 HashMap 相同 数组 + 链表/红黑树，对数据的每个 node 用 synchronized 和 CAS 操作，进一步降低了锁的粒度。

### Thread 线程

**线程状态：**

- NEW
- RUNNABLE
- BLOCKED
- WAITING
- TIMED WAITING
- TERMINATE

![线程状态切换](https://img-blog.csdnimg.cn/img_convert/758be9817fc978cb45b1501c949322ff.png)

**线程通信：**

- 锁 + Object.wait()/Object.notify()
- volatile

#### ThreadLocal

**引用类型：**

- 强引用
- 软饮用
- 弱引用
- 虚引用

**ThreadLocalMap:**

#### 线程池

**配置参数：**

- 核心线程数，核心线程数量
- 最大线程数，最大线程数量
- 存活时间，线程池中非核心线程空闲时间
- 存活时间单位
- 线程工厂，
- 阻塞线程队列，存放任务
- 线程池满淘汰策略，线程池饱淘汰任务策略

**异常处理：**

- 使用线程池的 submit() 返回 FutureTask.get() 抛出异常，try...catch 处理。
- 自定义 ThreadFactory，创建线程时设置 UncaughtExcepthonHandler ，在 uncaughtException() 中处理。
- 重新 ThreadPoolExecutor 的 afterExecute()，任务执行异常可以在此方法中拿到。

**默认实现：**

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduleThreadPool

**工作队列：**

- ArrayBlockingQueue
- LinkedBlockingQueue
- DelayQueue
- PriorityBlockingQueue
- SynchronousQueue

**拒绝策略：**

- AbortPolicy，抛出异常，默认
- CallerRunsPolicy，调用线程执行
- DiscardPolicy，丢弃
- DiscardOldestPolicy，丢弃最老

### 并发编程 JUC

#### 锁分类

- 偏向锁，轻量级锁，重量级锁
- 乐观锁，悲观锁
- 公平锁，非公平锁

#### synchronized

- 非公平锁
- 可冲入
- 锁升级

#### JMM（Java 内存模型）

#### AQS

#### ReentrantLock 可冲入锁

### BIO/NIO

## JVM

**调优指标：**

- 停顿时间
- 吞吐量
- 垃圾回收频率

**排查工具：**

- jps，查看 Java 进程
- jstat，Java 进程统计信息，常用于查看 GC 情况
- jinfo，Java 进程运行参数
- jmap，Java 进程的内存信息，可用于将内存信息导出为 dump 文件，使用 MAT 工具进行分析
- jstack，用于查看线程信息，排查死锁问题
- ali 的 arthas 开源诊断工具

**JIT 即时编译优化：**

- 方法內联
- 逃逸分析
  - 锁消除
  - 栈上分配
  - 标量替换

**类加载过程：**

- 加载，装载 class 文件到 JVM 的方法区
- 链接，验证 class 文件并初始化类变量为零值
  - 验证，验证 class 文件
  - 准备，赋零值
  - 解析，符号引用转直接引用
- 初始化，类变量初始化为默认值

**类加载器：**

- BootstrapClassloader
- ExtClassloader
- AppClassloader

**双亲委派：**

一种安全机制，保证 JDK 核心类库不被破坏。一个字节码类文件被两个不同的加载器加载是两个不同的类。

如何区分两个类是不同的：

- 类的全限定名
- 类加载器

**打破双亲委派：**

- 自定义 Classloader，重写 loadClass()。
    Tomcat Web容器，运行多个服务端，通过每个应用的类加载器 WebAppClassloader 打破双亲委派机制将 Web 应用隔离开。
    如果加载不到，再委托 ShareClassloader 加载。
    CommonClassloader，CatalinaClassloader
- SPI 机制
    JDBC 的 DriverManager 通过线程获取线程的 contextClassloader ，实际上是 AppClassloader，使用 contextClassloader 对 SPI 引入的 Driver 进行加载。

**JVM 运行时数据区结构：**

- 线程共享
  - 堆
  - 方法区
- 线程独享
  - 虚拟机栈
  - 本地方法栈
  - 程序计数器

## Spring、Spring Boot

## 微服务 Spring Cloud

### 配置中心 Nacos

### 服务注册与发现 Nacos 、Eureka

## Netty

## 分布式

### CAP

### BASE

### 分布式算法

## 数据库

### MySQL

### Redis

### Mongodb

## 中间件

### 消息队列

#### kafka

#### RocketMQ

#### RabbitMQ

### Zookeeper

## 容器化

### Docker

### k8s
