# 面试

## 计算机网络

## 设计模式

### 六大原则

- 单一职责原则。
- 开闭原则。
- 里氏替换原则。
- 依赖倒置原则。
- 接口隔离原则。
- 迪米特法则（最少知道原则）。

### 经典 21 种设计

- 单利模式
- 工厂模式
- 代理模式
- 建造者模式
- 模板方法模式
- 外观模式（门面模式）
- 原型模式
- 策略模式
- 观察者模式
- 。。。
- 装饰器模式

## Java SE

## 集合

### List

- ArrayList
- LinkedList

### Map

- 链表转红黑树阈值：8
- 扩容方法 resize 调用条件：
  - map 初始化。
  - map 中存储的 key-value 数量大于 threshold 。

#### ConsurrentHashMap

- HashTable 使用 synchronized 对全表加锁，锁的粒度大效率低。
- JDK 1.7 使用 segement 数组 + HashEntry 链表数组结构，对 segement 加锁实现同步，相对于 HashTable 降低了锁的粒度。
- JDK 1.8 之后，结构与 HashMap 相同 数组 + 链表/红黑树，对数据的每个 node 用 synchronized 和 CAS 操作，进一步降低了锁的粒度。

### IO

- 阻塞与非阻塞
- 同步与异步

**IO 模型：**

- 阻塞 IO
- 非阻塞 IO
- IO 复用，
  - select 模型
  - epoll 模型
- 信号驱动
- 异步 IO

**零拷贝：**

- 用户态
- 内核态

> 没有优化的情况下，IO 操作要经过 4次拷贝发生 4次上下文切换。
>
> 通过 DMA 硬件支持，CPU 把数据拷贝的工作交给 DMA
>
> kafka 使用零拷贝提高 IO 性能

- mmap
- sendfile

#### BIO 阻塞 IO

#### NIO 非阻塞 IO

**核心组件：**

- Buffer
- Channel
- Selector

### Thread 线程

**线程状态：**

- NEW
- RUNNABLE
- BLOCKED
- WAITING
- TIMED WAITING
- TERMINATE

![线程状态切换](https://img-blog.csdnimg.cn/img_convert/758be9817fc978cb45b1501c949322ff.png)

**线程通信：**

- 锁 + Object.wait()/Object.notify()
- volatile

**线程安全：**

> 可见性，volatile
> 原子性，sychronized
> 有序性，volatile

**死锁：**

> 原因：
>
> > 多线程场景下
> >
> > 1. 互斥条件，一个资源只能被一个线程使用
> > 2. 请求保持，一个线程阻塞后，对已经获得的资源保持不放
> > 3. 不可剥夺，一个进程获取资源后，在未使用完前，不能被剥夺
> > 4. 循环等待，多个线程循环等待资源
> >
> 排查死锁：
> > jstack -l \<PID>
>
> 如何避免：
> > 加锁顺序
> >
> > 减小死锁范围
> >
> > 锁自动释放

#### ThreadLocal

**引用类型：**

- 强引用
- 软饮用
- 弱引用
- 虚引用

**ThreadLocalMap:**

#### 线程池

**配置参数：**

- 核心线程数，核心线程数量
- 最大线程数，最大线程数量
- 存活时间，线程池中非核心线程空闲时间
- 存活时间单位
- 线程工厂，
- 阻塞线程队列，存放任务
- 线程池满淘汰策略，线程池饱淘汰任务策略

**异常处理：**

- 使用线程池的 submit() 返回 FutureTask.get() 抛出异常，try...catch 处理。
- 自定义 ThreadFactory，创建线程时设置 UncaughtExcepthonHandler ，在 uncaughtException() 中处理。
- 重新 ThreadPoolExecutor 的 afterExecute()，任务执行异常可以在此方法中拿到。

**默认实现：**

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduleThreadPool

**工作队列：**

- ArrayBlockingQueue
- LinkedBlockingQueue
- DelayQueue
- PriorityBlockingQueue
- SynchronousQueue

**拒绝策略：**

- AbortPolicy，抛出异常，默认
- CallerRunsPolicy，调用线程执行
- DiscardPolicy，丢弃
- DiscardOldestPolicy，丢弃最老

### 并发编程 JUC

#### 锁分类

- 偏向锁，轻量级锁，重量级锁
- 乐观锁，悲观锁
- 公平锁，非公平锁

#### synchronized

- 非公平锁
- 可重入
- 锁升级

**对象内存结构：**

- 对象头
  - Mark word，记录对象的锁信息
- 实例数据
- 附加信息

**原理：**

> 编译器生成 ACC_SYNCHRONIZED 关键字标识锁
>
> 以来操作系统的 monitorenter 和 monitorexist 指令
>
> JDK 1.6 之前是重量级锁，JDK 1.6 之后修改了锁的实现
> >
> > mutex 是操作系统指令，使用时会有用户态和内核态的切换影响性能。
> >
> > JDK 1.6 之后引入了偏向锁和轻量级锁，JVM 层面减少用户态和内核态的切换。
> >
> > 优化了线程竞争资源不激烈的场景。

#### CAS，Compare And Sweep

> CPU 原语操纵，JDK 的 Unsafe 在 JVM 使用 CPU 指令 cmpxchg

**CAS 问题：**

- ABA 问题，通过版本号解决
- 自旋性能浪费

#### JMM（Java 内存模型）

#### AQS

![AQS](https://pica.zhimg.com/80/v2-99ff696984f73f419012e3287c5a5f18_1440w.webp?source=1940ef5c)

- ReentrantLock
- ReentrantReadWriteLock
- CountDownLatch
- Semaphore

#### ReentrantLock 可冲入锁

## JVM

**调优指标：**

- 停顿时间
- 吞吐量
- 垃圾回收频率

**排查工具：**

- jps，查看 Java 进程
- jstat，Java 进程统计信息，常用于查看 GC 情况
- jinfo，Java 进程运行参数
- jmap，Java 进程的内存信息，可用于将内存信息导出为 dump 文件，使用 MAT 工具进行分析
- jstack，用于查看线程信息，排查死锁问题
- ali 的 arthas 开源诊断工具

**JIT 即时编译优化：**

- 方法內联
- 逃逸分析
  - 锁消除
  - 栈上分配
  - 标量替换

**类加载过程：**

- 加载，装载 class 文件到 JVM 的方法区
- 链接，验证 class 文件并初始化类变量为零值
  - 验证，验证 class 文件
  - 准备，赋零值
  - 解析，符号引用转直接引用
- 初始化，类变量初始化为默认值

**类加载器：**

- BootstrapClassloader
- ExtClassloader
- AppClassloader

**双亲委派：**

一种安全机制，保证 JDK 核心类库不被破坏。一个字节码类文件被两个不同的加载器加载是两个不同的类。

如何区分两个类是不同的：

- 类的全限定名
- 类加载器

**打破双亲委派：**

- 自定义 Classloader，重写 loadClass()。
    Tomcat Web容器，运行多个服务端，通过每个应用的类加载器 WebAppClassloader 打破双亲委派机制将 Web 应用隔离开。
    如果加载不到，再委托 ShareClassloader 加载。
    CommonClassloader，CatalinaClassloader
- SPI 机制
    JDBC 的 DriverManager 通过线程获取线程的 contextClassloader ，实际上是 AppClassloader，使用 contextClassloader 对 SPI 引入的 Driver 进行加载。

**JVM 运行时数据区结构：**

> Java 内存模型，与并发相关，屏蔽了计算机底层的细节，在上层调用 api 时不关心底层实现，并且屏蔽了操作系统的差异。
>
> Java 内存结构，运行时数据区，

- 线程共享
  - 堆，垃圾回收
    - 新生代
      - Eden
      - Survivor
        - From
        - To
    - 老年代
    - 常量池
      - 静态
      - 动态
  - 方法区，元空间
    - 类信息
- 线程独享
  - 虚拟机栈
    - 栈帧，每个方法调用创建一个栈帧
      - 操作数栈
      - 局部变量表
      - 方法返回值
      - 动态链接
  - 本地方法栈
  - 程序计数器，记录线程执行的字节码地址

### 垃圾回收

> JVM 垃圾，不再使用的对象。

**怎么确定一个对象是垃圾？**

- 引用计数法
- 可达性分析法
  - GC Roots，向下寻找，可以关联到的对象就是可达。
    - 栈帧局部变量表
    - 方法区
  
**垃圾回收算法：**

- 标记-清除
- 标记-复制
- 标记-整理

**常用的垃圾回收器：**

- 新生代
  - Serial
  - Parallel Scavenge
  - ParNew
- 老年代
  - Serial Old
  - Parallel Old
  - CMS，Concurrent Mark Sweep
    1. 初始标记，STW 扫描年轻代标记老年代被年轻代对象指向的对象
    2. 并发标记，根据 GC Root 标记可达对象。
    3. 并发预处理
    4. 重新标记，STW
    5. 重新标记，STW
    6. 并发清除
    > 空间预留
    > 内存碎片，出发 Full GC，STW，Serial Old
- G1
- ZGC

**垃圾回收类型：**

- Minor GC
- Major GC
- Full GC

## Spring、Spring Boot

## 微服务 Spring Cloud

### 配置中心 Nacos

### 服务注册与发现 Nacos 、Eureka

## Netty

## 分布式

### CAP

### BASE

### 分布式算法

## 数据库

### MySQL

### Redis

### Mongodb

## 中间件

### 消息队列

#### kafka

**如何保持消息顺序消费？**

**消息积压如何处理？**

#### RocketMQ

#### RabbitMQ

### Zookeeper

## 容器化

### Docker

### k8s
